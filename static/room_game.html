<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Hurve Room</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="/app.css" type="text/css" rel="stylesheet" />
  </head>

  <body>
    <div class="wrap">
      <header>
        <div class="row container">
          <strong class="brand">Hurve Room</strong>
          <span>Round: <span id="round">—</span></span>
          <span class="badge"
            ><span class="badge-dot"></span>Phase:
            <span id="phase">—</span></span
          >
          <div class="scoreboard" id="scoreboard"></div>
        </div>
      </header>
      <div id="arena" class="container">
        <div class="canvas-wrap">
          <canvas id="canvas" width="800" height="600"></canvas>
        </div>
      </div>
      <footer>
        Controls: &larr;/A turn left, &rarr;/D turn right, release = straight.
      </footer>
    </div>
    <script>
      (() => {
        // -----------------------------
        // Constants & DOM
        // -----------------------------
        const HEARTBEAT_MS = 500;
        const SCALE = 1;

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d", {
          alpha: false,
          desynchronized: true,
        });
        const elRound = document.getElementById("round");
        const elPhase = document.getElementById("phase");
        const scoreboardDiv = document.getElementById("scoreboard");

        // Keep 1px “pixel” look for Path2D rects
        ctx.imageSmoothingEnabled = false;

        // -----------------------------
        // URL → WS URL resolution
        // -----------------------------
        const params = new URLSearchParams(window.location.search);
        const wsUrlParam = params.get("wsUrl");
        const roomId = params.get("roomId");
        const token = params.get("token");
        let WS_URL;
        if (roomId && token) {
          const protocol = location.protocol === "https:" ? "wss://" : "ws://";
          WS_URL = protocol + location.host + "/ws/" + roomId + "/" + token;
        } else if (wsUrlParam) {
          WS_URL = wsUrlParam;
        } else {
          alert("Missing room or token in URL");
          return;
        }

        // -----------------------------
        // Functional helpers
        // -----------------------------
        const colorFor = (pid) => {
          const colors = [
            "#22d3ee",
            "#a78bfa",
            "#34d399",
            "#fbbf24",
            "#f472b6",
            "#60a5fa",
            "#f87171",
          ];
          return colors[pid % colors.length];
        };

        const byPid = (cells) =>
          cells.reduce((acc, c) => {
            const x = Array.isArray(c) ? c[0] : c.x ?? c.t0 ?? 0;
            const y = Array.isArray(c) ? c[1] : c.y ?? c.t1 ?? 0;
            const pid = Array.isArray(c) ? c[2] : c.pid ?? c.t2 ?? 0;
            (acc[pid] || (acc[pid] = [])).push({ x, y, pid });
            return acc;
          }, {});

        // Builds fresh paths for a full trails snapshot
        const buildPathsFromTrails = (trails) => {
          const groups = byPid(trails || []);
          const paths = new Map();
          for (const pidStr of Object.keys(groups)) {
            const pid = Number(pidStr);
            const p = new Path2D();
            for (const { x, y } of groups[pid]) {
              p.rect(
                Math.round(x * SCALE),
                Math.round(y * SCALE),
                SCALE,
                SCALE
              );
            }
            paths.set(pid, p);
          }
          return paths;
        };

        // Appends cells to an existing paths map (mutates Path2D objects; returns same Map for ergonomic "functional-ish" use)
        const appendCellsToPaths = (paths, cells) => {
          if (!cells || !cells.length) return paths;
          const groups = byPid(cells);
          for (const pidStr of Object.keys(groups)) {
            const pid = Number(pidStr);
            const existing = paths.get(pid) || new Path2D();
            for (const { x, y } of groups[pid]) {
              existing.rect(Math.round(x * SCALE), Math.round(y * SCALE), 1, 1);
            }
            paths.set(pid, existing);
          }
          return paths;
        };

        const applyWorldResize = (world) => {
          if (!world) return;
          const w = Math.round(world.width * SCALE);
          const h = Math.round(world.height * SCALE);
          if (canvas.width !== w || canvas.height !== h) {
            canvas.width = w;
            canvas.height = h;
            // No need to rebuild paths here; caller decides whether to rebuild/clear
          }
        };

        const clearCanvasHard = () => {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
        };

        const drawPaths = (paths) => {
          for (const [pid, path] of paths) {
            ctx.strokeStyle = colorFor(pid);
            ctx.stroke(path);
          }
        };

        function drawPlayers(world) {
          if (!world || !world.players) return;

          // tiny helpers for color tweaks
          const hexToRgb = (hex) => {
            const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            if (!m) return { r: 255, g: 255, b: 255 };
            return {
              r: parseInt(m[1], 16),
              g: parseInt(m[2], 16),
              b: parseInt(m[3], 16),
            };
          };
          const rgbToCss = ({ r, g, b }, a = 1) =>
            `rgba(${r | 0},${g | 0},${b | 0},${a})`;
          const shade = (hex, k) => {
            // k in [-1,1]; <0 darken, >0 lighten
            const { r, g, b } = hexToRgb(hex);
            const mix = (c) =>
              Math.max(0, Math.min(255, c + (k >= 0 ? (255 - c) * k : c * k)));
            return rgbToCss({ r: mix(r), g: mix(g), b: mix(b) });
          };

          for (const p of world.players) {
            const x = Number(p.pos.px) * SCALE;
            const y = Number(p.pos.py) * SCALE;
            const r = (world.headRadiusPx || 2) * SCALE;
            const theta = Number(p.dir);
            const base = colorFor(p.pid);
            const alive = !!p.alive;

            // choose palette
            const fillLight = shade(base, 0.35);
            const fillDark = shade(base, -0.35);
            const ringColor = shade(base, -0.55);
            const noseColor = "#ffffff";

            // draw head with gradient + ring, rotated to face dir
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(theta);

            // soft drop shadow (cheap)
            ctx.save();
            ctx.globalAlpha = 0.25;
            ctx.beginPath();
            ctx.ellipse(0, r * 0.25, r * 0.95, r * 0.55, 0, 0, Math.PI * 2);
            ctx.fillStyle = "black";
            ctx.fill();
            ctx.restore();

            // glossy fill
            const g = ctx.createRadialGradient(
              -r * 0.3,
              -r * 0.3,
              r * 0.2,
              0,
              0,
              r
            );
            g.addColorStop(0, fillLight);
            g.addColorStop(1, fillDark);
            ctx.beginPath();
            ctx.arc(0, 0, r, 0, Math.PI * 2);
            ctx.fillStyle = alive ? g : "rgba(120,120,120,0.7)"; // dead = greyed
            ctx.fill();

            // rim/ring
            ctx.lineWidth = Math.max(1, r * 0.18);
            ctx.strokeStyle = alive ? ringColor : "rgba(80,80,80,0.6)";
            ctx.stroke();

            if (alive) {
              // small forward wedge “nose”
              ctx.beginPath();
              ctx.moveTo(r * 1.05, 0);
              ctx.lineTo(r * 0.55, r * 0.28);
              ctx.lineTo(r * 0.55, -r * 0.28);
              ctx.closePath();
              ctx.fillStyle = noseColor;
              ctx.globalAlpha = 0.9;
              ctx.fill();
              ctx.globalAlpha = 1;

              // eyes (white) + pupils (dark), slightly forward & spaced
              const eyeY = r * 0.28;
              const eyeX = r * 0.15;
              const eyeR = Math.max(1, r * 0.18);
              const pupilR = Math.max(1, r * 0.1);

              // whites
              ctx.beginPath();
              ctx.arc(eyeX, eyeY, eyeR, 0, Math.PI * 2);
              ctx.arc(eyeX, -eyeY, eyeR, 0, Math.PI * 2);
              ctx.fillStyle = "white";
              ctx.fill();

              // pupils—biased forward
              ctx.beginPath();
              ctx.arc(eyeX + r * 0.1, eyeY * 0.75, pupilR, 0, Math.PI * 2);
              ctx.arc(eyeX + r * 0.1, -eyeY * 0.75, pupilR, 0, Math.PI * 2);
              ctx.fillStyle = "rgba(20,20,30,0.95)";
              ctx.fill();

              // tiny specular highlight
              ctx.beginPath();
              ctx.arc(-r * 0.35, -r * 0.35, r * 0.18, 0, Math.PI * 2);
              ctx.fillStyle = "rgba(255,255,255,0.25)";
              ctx.fill();
            } else {
              // crossed-out eyes for dead players (fun!)
              ctx.lineWidth = Math.max(1, r * 0.12);
              ctx.strokeStyle = "rgba(40,40,40,0.9)";
              ctx.beginPath();
              ctx.moveTo(-r * 0.35, -r * 0.35);
              ctx.lineTo(r * 0.35, r * 0.35);
              ctx.moveTo(-r * 0.35, r * 0.35);
              ctx.lineTo(r * 0.35, -r * 0.35);
              ctx.stroke();
            }

            ctx.restore();
          }
        }

        const updateScoreboard = (scoreList) => {
          const el = document.getElementById("scoreboard");
          el.innerHTML = "";
          if (!Array.isArray(scoreList)) return;
          for (const [pid, pts] of scoreList) {
            const s = document.createElement("span");
            s.className = "score";
            s.innerHTML = `<span class="dot" style="background:${colorFor(
              pid
            )}"></span>P${pid}: ${pts}`;
            el.appendChild(s);
          }
        };

        const updateStatus = (phase, round) => {
          if (phase != null) elPhase.textContent = phase;
          if (round != null) elRound.textContent = round;
        };

        // -----------------------------
        // State & reducer-like setter
        // -----------------------------
        const initialState = Object.freeze({
          socket: null,
          myPid: null,
          seq: 1,
          currentTurn: "Straight",
          lastSentTurn: "Straight",
          world: null,
          pathsByPid: new Map(),
          lastPhase: null,
          lastRound: null,
        });

        let state = initialState;

        const setState = (update) => {
          // update can be partial object or (prev) => newPartial
          const patch = typeof update === "function" ? update(state) : update;
          state = { ...state, ...patch };
          return state;
        };

        // -----------------------------
        // WebSocket wiring
        // -----------------------------
        const sendInput = (turn) => {
          const { socket, myPid, seq } = state;
          if (!socket || socket.readyState !== 1 || myPid == null) return;
          const payload = ["input", seq, myPid, turn];
          try {
            socket.send(JSON.stringify(payload));
            setState({ seq: seq + 1 });
          } catch {}
        };

        const handleWelcome = (pid, w) => {
          setState({ myPid: pid, world: w });
          applyWorldResize(w);
          // Full rebuild from world.trails (per-player colouring assumed)
          const paths = buildPathsFromTrails(w && w.trails);
          clearCanvasHard();
          setState({ pathsByPid: paths, lastPhase: null, lastRound: null });
          updateScoreboard([]);
          updateStatus("", "");
        };

        const handleState = (obj) => {
          const phase = obj.phase;
          const round = obj.round;

          const phaseJustStartedPlaying =
            phase === "Playing" && state.lastPhase !== "Playing";
          const roundChanged =
            typeof round === "number" && round !== state.lastRound;

          // World updates may contain a fresh snapshot of trails or just deltas.
          let worldNext = state.world;
          if (obj.world) {
            worldNext = obj.world;
            applyWorldResize(worldNext);
          }

          let pathsNext = state.pathsByPid;

          if (phaseJustStartedPlaying || roundChanged) {
            // Reset visuals on round/phase start
            clearCanvasHard();
            pathsNext = new Map();
          }

          if (obj.world && Array.isArray(obj.world.trails)) {
            // Fresh full snapshot provided: rebuild
            pathsNext = buildPathsFromTrails(obj.world.trails);
          } else if (Array.isArray(obj.deltaTrails) && obj.deltaTrails.length) {
            // Optional incremental form if your server sends it
            pathsNext = appendCellsToPaths(pathsNext, obj.deltaTrails);
          }

          if (obj.score) updateScoreboard(obj.score);
          updateStatus(phase, round);

          setState({
            world: worldNext,
            pathsByPid: pathsNext,
            lastPhase: phase,
            lastRound: round,
          });

          // Send current turn for next tick
          sendInput(state.currentTurn);
        };

        const connect = () => {
          // Close previous socket if any
          if (state.socket) {
            try {
              state.socket.close();
            } catch {}
          }
          const socket = new WebSocket(WS_URL);
          setState({ socket });

          socket.onopen = () => {
            // Kick off with a straight input to get welcome/ack
            sendInput("Straight");
            setState({ lastSentTurn: "Straight" });
          };

          socket.onmessage = (ev) => {
            let msg;
            try {
              msg = JSON.parse(ev.data);
            } catch {
              return;
            }
            if (!Array.isArray(msg)) return;
            const [t, ...rest] = msg;
            if (t === "welcome") {
              const [pid, w] = rest;
              handleWelcome(pid, w);
            } else if (t === "state") {
              const [_tick, obj] = rest;
              handleState(obj || {});
            }
          };

          socket.onclose = () => {
            // Attempt reconnect after 1 second
            setTimeout(connect, 1000);
          };
        };

        // -----------------------------
        // Input handling (functional-ish)
        // -----------------------------
        const keys = new Set();
        const computeTurn = (ks) => {
          const left = ks.has("ArrowLeft") || ks.has("KeyA");
          const right = ks.has("ArrowRight") || ks.has("KeyD");
          return left && !right
            ? "Left"
            : right && !left
            ? "Right"
            : "Straight";
        };

        const maybeSendTurn = () => {
          const { currentTurn, lastSentTurn } = state;
          if (currentTurn !== lastSentTurn) {
            sendInput(currentTurn);
            setState({ lastSentTurn: currentTurn });
          }
        };

        addEventListener("keydown", (e) => {
          if (["ArrowLeft", "ArrowRight", "KeyA", "KeyD"].includes(e.code))
            e.preventDefault();
          if (!keys.has(e.code)) {
            keys.add(e.code);
            const next = computeTurn(keys);
            setState({ currentTurn: next });
            maybeSendTurn();
          }
        });

        addEventListener("keyup", (e) => {
          if (keys.has(e.code)) {
            keys.delete(e.code);
            const next = computeTurn(keys);
            setState({ currentTurn: next });
            maybeSendTurn();
          }
        });

        // -----------------------------
        // Render loop
        // -----------------------------
        const frame = () => {
          clearCanvasHard();
          // Trail (paths) first, then players on top
          const { pathsByPid, world } = state;
          drawPaths(pathsByPid);
          drawPlayers(world);
          requestAnimationFrame(frame);
        };

        // -----------------------------
        // Heartbeat & boot
        // -----------------------------
        setInterval(() => {
          sendInput("Straight");
        }, HEARTBEAT_MS);

        connect();
        requestAnimationFrame(frame);
      })();
    </script>
  </body>
</html>
