<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>Hurve Room</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0d12;
      --fg: #e8eef8;
      --muted: #94a3b8;
      --accent: #22d3ee;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 14px/1.35 system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
    }

    .wrap {
      display: flex;
      flex-direction: column;
      height: 100%;
    }

    header {
      padding: 10px 12px;
      display: flex;
      align-items: center;
      gap: 12px;
      border-bottom: 1px solid #1f2937;
    }

    #phase,
    #round {
      min-width: 50px;
    }

    .scoreboard {
      margin-left: auto;
      display: flex;
      gap: 12px;
    }

    .scoreboard .player {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .scoreboard .dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
      display: inline-block;
    }

    #arena {
      flex: 1;
      display: grid;
      place-items: center;
      padding: 12px;
    }

    canvas {
      background: #000;
      box-shadow: 0 8px 30px rgba(0, 0, 0, 0.45);
      border-radius: 12px;
      image-rendering: pixelated;
    }

    footer {
      padding: 10px 12px;
      border-top: 1px solid #1f2937;
      color: var(--muted);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <header>
      <strong>Hurve Room</strong>
      <span>Round: <span id="round">—</span></span>
      <span>Phase: <span id="phase">—</span></span>
      <div class="scoreboard" id="scoreboard"></div>
    </header>
    <div id="arena">
      <canvas id="canvas" width="800" height="600"></canvas>
    </div>
    <footer>
      Controls: &larr;/A turn left, &rarr;/D turn right, release = straight.
    </footer>
  </div>
  <script>
    (function () {
      // -----------------------------
      // Constants & DOM
      // -----------------------------
      const HEARTBEAT_MS = 500;
      const SCALE = 1;

      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
      const elRound = document.getElementById('round');
      const elPhase = document.getElementById('phase');
      const scoreboardDiv = document.getElementById('scoreboard');

      // Keep 1px “pixel” look for Path2D rects
      ctx.imageSmoothingEnabled = false;

      // -----------------------------
      // URL → WS URL resolution
      // -----------------------------
      const params = new URLSearchParams(window.location.search);
      const wsUrlParam = params.get('wsUrl');
      const roomId = params.get('roomId');
      const token = params.get('token');
      let WS_URL;
      if (roomId && token) {
        const protocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
        WS_URL = protocol + location.host + '/ws/' + roomId + '/' + token;
      } else if (wsUrlParam) {
        WS_URL = wsUrlParam;
      } else {
        alert('Missing room or token in URL');
        return;
      }

      // -----------------------------
      // Functional helpers
      // -----------------------------
      const colorFor = (pid) => {
        const colors = ['#22d3ee', '#a78bfa', '#34d399', '#fbbf24', '#f472b6', '#60a5fa', '#f87171'];
        return colors[pid % colors.length];
      };

      const byPid = (cells) =>
        cells.reduce((acc, c) => {
          const x = Array.isArray(c) ? c[0] : (c.x ?? c.t0 ?? 0);
          const y = Array.isArray(c) ? c[1] : (c.y ?? c.t1 ?? 0);
          const pid = Array.isArray(c) ? c[2] : (c.pid ?? c.t2 ?? 0);
          (acc[pid] || (acc[pid] = [])).push({ x, y, pid });
          return acc;
        }, {});

      // Builds fresh paths for a full trails snapshot
      const buildPathsFromTrails = (trails) => {
        const groups = byPid(trails || []);
        const paths = new Map();
        for (const pidStr of Object.keys(groups)) {
          const pid = Number(pidStr);
          const p = new Path2D();
          for (const { x, y } of groups[pid]) {
            p.rect(Math.round(x * SCALE), Math.round(y * SCALE), 1, 1);
          }
          paths.set(pid, p);
        }
        return paths;
      };

      // Appends cells to an existing paths map (mutates Path2D objects; returns same Map for ergonomic "functional-ish" use)
      const appendCellsToPaths = (paths, cells) => {
        if (!cells || !cells.length) return paths;
        const groups = byPid(cells);
        for (const pidStr of Object.keys(groups)) {
          const pid = Number(pidStr);
          const existing = paths.get(pid) || new Path2D();
          for (const { x, y } of groups[pid]) {
            existing.rect(Math.round(x * SCALE), Math.round(y * SCALE), 1, 1);
          }
          paths.set(pid, existing);
        }
        return paths;
      };

      const applyWorldResize = (world) => {
        if (!world) return;
        const w = Math.round(world.width * SCALE);
        const h = Math.round(world.height * SCALE);
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
          // No need to rebuild paths here; caller decides whether to rebuild/clear
        }
      };

      const clearCanvasHard = () => {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      };

      const drawPaths = (paths, players) => {
        // If players provided, draw in that order (stable color layering); otherwise iterate paths map.
        if (Array.isArray(players)) {
          for (const p of players) {
            const path = paths.get(p.pid);
            if (!path) continue;
            ctx.fillStyle = colorFor(p.pid);
            ctx.fill(path);
          }
        } else {
          for (const [pid, path] of paths) {
            ctx.fillStyle = colorFor(pid);
            ctx.fill(path);
          }
        }
      };

      const drawPlayers = (world) => {
        if (!world || !world.players) return;
        for (const p of world.players) {
          const x = Number(p.pos.px) * SCALE;
          const y = Number(p.pos.py) * SCALE;
          const r = (world.headRadiusPx || 2) * SCALE;

          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI * 2);
          ctx.fillStyle = p.alive ? colorFor(p.pid) : 'rgba(120,120,120,0.7)';
          ctx.fill();

          const theta = Number(p.dir);
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(theta) * (r + 4), y + Math.sin(theta) * (r + 4));
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
      };

      const updateScoreboard = (scoreList) => {
        scoreboardDiv.innerHTML = '';
        if (!Array.isArray(scoreList)) return;
        for (const [pid, pts] of scoreList) {
          const span = document.createElement('span');
          span.className = 'player';
          const dot = document.createElement('span');
          dot.className = 'dot';
          dot.style.background = colorFor(pid);
          span.appendChild(dot);
          span.appendChild(document.createTextNode('P' + pid + ': ' + pts));
          scoreboardDiv.appendChild(span);
        }
      };

      const updateStatus = (phase, round) => {
        if (phase != null) elPhase.textContent = phase;
        if (round != null) elRound.textContent = round;
      };

      // -----------------------------
      // State & reducer-like setter
      // -----------------------------
      const initialState = Object.freeze({
        socket: null,
        myPid: null,
        seq: 1,
        currentTurn: 'Straight',
        lastSentTurn: 'Straight',
        world: null,
        pathsByPid: new Map(),
        lastPhase: null,
        lastRound: null,
      });

      let state = initialState;

      const setState = (update) => {
        // update can be partial object or (prev) => newPartial
        const patch = typeof update === 'function' ? update(state) : update;
        state = { ...state, ...patch };
        return state;
      };

      // -----------------------------
      // WebSocket wiring
      // -----------------------------
      const sendInput = (turn) => {
        const { socket, myPid, seq } = state;
        if (!socket || socket.readyState !== 1 || myPid == null) return;
        const payload = ['input', seq, myPid, turn];
        try {
          socket.send(JSON.stringify(payload));
          setState({ seq: seq + 1 });
        } catch { }
      };

      const handleWelcome = (pid, w) => {
        setState({ myPid: pid, world: w });
        applyWorldResize(w);
        // Full rebuild from world.trails (per-player colouring assumed)
        const paths = buildPathsFromTrails(w && w.trails);
        clearCanvasHard();
        setState({ pathsByPid: paths, lastPhase: null, lastRound: null });
        updateScoreboard([]);
        updateStatus('', '');
      };

      const handleState = (obj) => {
        const phase = obj.phase;
        const round = obj.round;

        const phaseJustStartedPlaying = (phase === 'Playing' && state.lastPhase !== 'Playing');
        const roundChanged = (typeof round === 'number' && round !== state.lastRound);

        // World updates may contain a fresh snapshot of trails or just deltas.
        let worldNext = state.world;
        if (obj.world) {
          worldNext = obj.world;
          applyWorldResize(worldNext);
        }

        let pathsNext = state.pathsByPid;

        if (phaseJustStartedPlaying || roundChanged) {
          // Reset visuals on round/phase start
          clearCanvasHard();
          pathsNext = new Map();
        }

        if (obj.world && Array.isArray(obj.world.trails)) {
          // Fresh full snapshot provided: rebuild
          pathsNext = buildPathsFromTrails(obj.world.trails);
        } else if (Array.isArray(obj.deltaTrails) && obj.deltaTrails.length) {
          // Optional incremental form if your server sends it
          pathsNext = appendCellsToPaths(pathsNext, obj.deltaTrails);
        }

        if (obj.score) updateScoreboard(obj.score);
        updateStatus(phase, round);

        setState({
          world: worldNext,
          pathsByPid: pathsNext,
          lastPhase: phase,
          lastRound: round,
        });

        // Send current turn for next tick
        sendInput(state.currentTurn);
      };

      const connect = () => {
        // Close previous socket if any
        if (state.socket) {
          try { state.socket.close(); } catch { }
        }
        const socket = new WebSocket(WS_URL);
        setState({ socket });

        socket.onopen = () => {
          // Kick off with a straight input to get welcome/ack
          sendInput('Straight');
          setState({ lastSentTurn: 'Straight' });
        };

        socket.onmessage = (ev) => {
          let msg;
          try { msg = JSON.parse(ev.data); } catch { return; }
          if (!Array.isArray(msg)) return;
          const [t, ...rest] = msg;
          if (t === 'welcome') {
            const [pid, w] = rest;
            handleWelcome(pid, w);
          } else if (t === 'state') {
            const [_tick, obj] = rest;
            handleState(obj || {});
          }
        };

        socket.onclose = () => {
          // Attempt reconnect after 1 second
          setTimeout(connect, 1000);
        };
      };

      // -----------------------------
      // Input handling (functional-ish)
      // -----------------------------
      const keys = new Set();
      const computeTurn = (ks) => {
        const left = ks.has('ArrowLeft') || ks.has('KeyA');
        const right = ks.has('ArrowRight') || ks.has('KeyD');
        return left && !right ? 'Left' : right && !left ? 'Right' : 'Straight';
      };

      const maybeSendTurn = () => {
        const { currentTurn, lastSentTurn } = state;
        if (currentTurn !== lastSentTurn) {
          sendInput(currentTurn);
          setState({ lastSentTurn: currentTurn });
        }
      };

      addEventListener('keydown', (e) => {
        if (['ArrowLeft', 'ArrowRight', 'KeyA', 'KeyD'].includes(e.code)) e.preventDefault();
        if (!keys.has(e.code)) {
          keys.add(e.code);
          const next = computeTurn(keys);
          setState({ currentTurn: next });
          maybeSendTurn();
        }
      });

      addEventListener('keyup', (e) => {
        if (keys.has(e.code)) {
          keys.delete(e.code);
          const next = computeTurn(keys);
          setState({ currentTurn: next });
          maybeSendTurn();
        }
      });

      // -----------------------------
      // Render loop
      // -----------------------------
      const frame = () => {
        // Trail (paths) first, then players on top
        const { pathsByPid, world } = state;
        drawPaths(pathsByPid, world?.players);
        drawPlayers(world);
        requestAnimationFrame(frame);
      };

      // -----------------------------
      // Heartbeat & boot
      // -----------------------------
      setInterval(() => {
        sendInput('Straight');
      }, HEARTBEAT_MS);

      connect();
      requestAnimationFrame(frame);
    })();
  </script>
</body>

</html>