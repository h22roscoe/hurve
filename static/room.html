<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <title>Hurve Room</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
        :root {
            --bg: #0b0d12;
            --fg: #e8eef8;
            --muted: #94a3b8;
            --accent: #22d3ee;
        }

        html,
        body {
            height: 100%;
            margin: 0;
            background: var(--bg);
            color: var(--fg);
            font: 14px/1.35 system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
        }

        .wrap {
            display: flex;
            flex-direction: column;
            height: 100%;
        }

        header {
            padding: 10px 12px;
            display: flex;
            align-items: center;
            gap: 12px;
            border-bottom: 1px solid #1f2937;
        }

        #phase,
        #round {
            min-width: 50px;
        }

        .scoreboard {
            margin-left: auto;
            display: flex;
            gap: 12px;
        }

        .scoreboard .player {
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .scoreboard .dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
        }

        #arena {
            flex: 1;
            display: grid;
            place-items: center;
            padding: 12px;
        }

        canvas {
            background: #000;
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.45);
            border-radius: 12px;
            image-rendering: pixelated;
        }

        footer {
            padding: 10px 12px;
            border-top: 1px solid #1f2937;
            color: var(--muted);
        }
    </style>
</head>

<body>
    <div class="wrap">
        <header>
            <strong>Hurve Room</strong>
            <span>Round: <span id="round">—</span></span>
            <span>Phase: <span id="phase">—</span></span>
            <div class="scoreboard" id="scoreboard"></div>
        </header>
        <div id="arena">
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>
        <footer>
            Controls: &larr;/A turn left, &rarr;/D turn right, release = straight.
        </footer>
    </div>
    <script>
        (function () {
            // Parse query parameters for roomId, token and wsUrl
            const params = new URLSearchParams(window.location.search);
            const wsUrlParam = params.get('wsUrl');
            const roomId = params.get('roomId');
            const token = params.get('token');
            let WS_URL;
            // Prefer constructing the WebSocket URL from the roomId and token. The
            // wsUrlParam may contain type names ("RoomId", "JoinToken") when
            // returned from the Haskell server, which makes the path invalid. Only
            // fall back to the wsUrlParam if roomId or token are missing.
            if (roomId && token) {
                const protocol = location.protocol === 'https:' ? 'wss://' : 'ws://';
                WS_URL = protocol + location.host + '/ws/' + roomId + '/' + token;
            } else if (wsUrlParam) {
                WS_URL = wsUrlParam;
            } else {
                alert('Missing room or token in URL');
                return;
            }
            const HEARTBEAT_MS = 500;
            const SCALE = 1;
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d', { alpha: false, desynchronized: true });
            const elRound = document.getElementById('round');
            const elPhase = document.getElementById('phase');
            const scoreboardDiv = document.getElementById('scoreboard');

            let socket = null;
            let myPid = null;
            let seq = 1;
            let currentTurn = 'Straight';
            let lastSentTurn = 'Straight';
            let world = null;
            let trailImg = null;
            let trailDirty = false;

            function colorFor(pid) {
                const colors = ['#22d3ee', '#a78bfa', '#34d399', '#fbbf24', '#f472b6', '#60a5fa', '#f87171'];
                return colors[pid % colors.length];
            }
            function applyWorldResize() {
                if (!world) return;
                const w = Math.round(world.width * SCALE);
                const h = Math.round(world.height * SCALE);
                if (canvas.width !== w || canvas.height !== h) {
                    canvas.width = w;
                    canvas.height = h;
                    trailImg = ctx.createImageData(w, h);
                    // Make the background opaque by filling alpha channel
                    for (let i = 3; i < trailImg.data.length; i += 4) {
                        trailImg.data[i] = 255;
                    }
                    trailDirty = true;
                }
            }
            function setPixel(img, x, y, colorHex) {
                if (!img) return;
                if (x < 0 || y < 0 || x >= img.width || y >= img.height) return;
                const idx = (y * img.width + x) * 4;
                const d = img.data;
                // convert hex colour (#rrggbb) to rgb
                const r = parseInt(colorHex.slice(1, 3), 16);
                const g = parseInt(colorHex.slice(3, 5), 16);
                const b = parseInt(colorHex.slice(5, 7), 16);
                d[idx] = r;
                d[idx + 1] = g;
                d[idx + 2] = b;
                d[idx + 3] = 255;
            }
            function rebuildTrail(trails) {
                if (!trailImg) return;
                // Clear image: reset color and alpha (alpha remains 255 for all)
                trailImg.data.fill(0);
                for (let i = 3; i < trailImg.data.length; i += 4) {
                    trailImg.data[i] = 255;
                }
                for (const cell of trails) {
                    const x = Array.isArray(cell) ? cell[0] : cell.x ?? cell.t0 ?? 0;
                    const y = Array.isArray(cell) ? cell[1] : cell.y ?? cell.t1 ?? 0;
                    // Use my colour for trail; other players will still show in different colour via drawPlayers
                    const col = colorFor(myPid || 0);
                    setPixel(trailImg, x, y, col);
                }
                trailDirty = true;
            }
            function drawTrail() {
                if (trailImg && trailDirty) {
                    ctx.putImageData(trailImg, 0, 0);
                    trailDirty = false;
                }
            }
            function drawPlayers() {
                if (!world || !world.players) return;
                for (const p of world.players) {
                    const x = Number(p.pos.px) * SCALE;
                    const y = Number(p.pos.py) * SCALE;
                    const r = (world.headRadiusPx || 2) * SCALE;
                    ctx.beginPath();
                    ctx.arc(x, y, r, 0, Math.PI * 2);
                    ctx.fillStyle = p.alive ? colorFor(p.pid) : 'rgba(120,120,120,0.7)';
                    ctx.fill();
                    const theta = Number(p.dir);
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(x + Math.cos(theta) * (r + 4), y + Math.sin(theta) * (r + 4));
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            function updateScoreboard(scoreList) {
                scoreboardDiv.innerHTML = '';
                if (!Array.isArray(scoreList)) return;
                scoreList.forEach(entry => {
                    const pid = entry[0];
                    const pts = entry[1];
                    const span = document.createElement('span');
                    span.className = 'player';
                    const dot = document.createElement('span');
                    dot.className = 'dot';
                    dot.style.background = colorFor(pid);
                    span.appendChild(dot);
                    const text = document.createTextNode('P' + pid + ': ' + pts);
                    span.appendChild(text);
                    scoreboardDiv.appendChild(span);
                });
            }
            function updateStatus(phase, round) {
                if (phase !== undefined && phase !== null) {
                    elPhase.textContent = phase;
                }
                if (round !== undefined && round !== null) {
                    elRound.textContent = round;
                }
            }
            function connect() {
                if (socket) {
                    try { socket.close(); } catch { };
                }
                socket = new WebSocket(WS_URL);
                socket.onopen = () => {
                    // Kick off with a straight input to get welcome/ack
                    sendInput('Straight');
                    lastSentTurn = 'Straight';
                };
                socket.onmessage = (ev) => {
                    let msg;
                    try { msg = JSON.parse(ev.data); } catch { return; }
                    if (!Array.isArray(msg)) return;
                    const [t, ...rest] = msg;
                    if (t === 'welcome') {
                        const [pid, w] = rest;
                        myPid = pid;
                        world = w;
                        applyWorldResize();
                        rebuildTrail((world && world.trails) || []);
                        updateScoreboard([]);
                        updateStatus('', '');
                    } else if (t === 'state') {
                        const [tick, obj] = rest;
                        if (obj.world) {
                            world = obj.world;
                            applyWorldResize();
                            if (world.trails) rebuildTrail(world.trails);
                        }
                        if (obj.score) {
                            updateScoreboard(obj.score);
                        }
                        updateStatus(obj.phase, obj.round);
                        // Send current turn to server for next tick
                        sendInput(currentTurn);
                    }
                };
                socket.onclose = () => {
                    // Attempt reconnect after 1 second
                    setTimeout(connect, 1000);
                };
            }
            function sendInput(turn) {
                if (!socket || socket.readyState !== 1 || myPid == null) return;
                const payload = ['input', seq, myPid, turn];
                try {
                    socket.send(JSON.stringify(payload));
                    seq++;
                } catch { }
            }
            // Keyboard handling
            const keys = new Set();
            addEventListener('keydown', (e) => {
                if (['ArrowLeft', 'ArrowRight', 'KeyA', 'KeyD'].includes(e.code)) e.preventDefault();
                if (!keys.has(e.code)) {
                    keys.add(e.code);
                    updateTurn();
                    maybeSend();
                }
            });
            addEventListener('keyup', (e) => {
                if (keys.has(e.code)) {
                    keys.delete(e.code);
                    updateTurn();
                    maybeSend();
                }
            });
            function updateTurn() {
                const left = keys.has('ArrowLeft') || keys.has('KeyA');
                const right = keys.has('ArrowRight') || keys.has('KeyD');
                currentTurn = left && !right ? 'Left' : right && !left ? 'Right' : 'Straight';
            }
            function maybeSend() {
                if (currentTurn !== lastSentTurn) {
                    sendInput(currentTurn);
                    lastSentTurn = currentTurn;
                }
            }
            // Heartbeat to keep connection alive
            setInterval(() => {
                sendInput('Straight');
            }, HEARTBEAT_MS);
            // Render loop
            function frame() {
                drawTrail();
                drawPlayers();
                requestAnimationFrame(frame);
            }
            connect();
            requestAnimationFrame(frame);
        })();
    </script>
</body>

</html>
