<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Hurve Room – Waiting</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link href="/app.css" type="text/css" rel="stylesheet" />
  </head>

  <body>
    <div class="wrap">
      <header>
        <div class="row container">
          <strong class="brand">Room – Waiting</strong>
          <span id="phase" class="badge"
            ><span class="badge-dot"></span>Phase: Waiting</span
          >
          <div class="spacer"></div>
          <button id="readyBtn" class="btn" title="Ready">Ready</button>
        </div>
      </header>
      <main class="container">
        <h3>Players</h3>
        <ul id="players" class="list"></ul>
      </main>
      <footer>
        This view will automatically switch to the game when the round starts.
      </footer>
    </div>
    <script>
      (() => {
        // ---------------------------
        // Params & derived WS URL
        // ---------------------------
        const q = new URLSearchParams(location.search);
        const roomId = q.get("roomId");
        const token = q.get("token");
        if (!roomId || !token) {
          alert("Missing roomId/token");
          return;
        }
        const WS_URL =
          (location.protocol === "https:" ? "wss://" : "ws://") +
          location.host +
          "/ws/" +
          roomId +
          "/" +
          token;

        // ---------------------------
        // DOM elements
        // ---------------------------
        const playersUl = document.getElementById("players");
        const phaseEl = document.getElementById("phase");
        const readyBtn = document.getElementById("readyBtn");

        // ---------------------------
        // Tiny helpers (pure)
        // ---------------------------
        const h = (tag, props = {}, children = []) => {
          const el = document.createElement(tag);
          for (const [k, v] of Object.entries(props)) {
            if (k === "class") el.className = v;
            else if (k === "dataset") Object.assign(el.dataset, v);
            else if (k === "style" && typeof v === "object")
              Object.assign(el.style, v);
            else el.setAttribute(k, v);
          }
          for (const c of children) {
            el.appendChild(
              typeof c === "string" ? document.createTextNode(c) : c
            );
          }
          return el;
        };
        const t = (s) => document.createTextNode(s);

        const viewPlayer = ({ pid, name = "Guest", ready = false }) =>
          h("li", { class: "list-item" }, [
            h("div", { class: "avatar", id: `player-${pid}` }, [`P${pid}`]),
            h("div", { class: "grow" }, [name]),
            h("span", { class: `badge ${ready ? "badge--ok" : ""}` }, [
              h("span", { class: "badge-dot" }, []),
              ready ? "Ready" : "Waiting",
            ]),
          ]);

        const viewPlayers = (players) => {
          const frag = document.createDocumentFragment();
          for (const p of players) frag.appendChild(viewPlayer(p));
          return frag;
        };

        // pure transforms for SSE events
        const playersUpsert = (players, p) => {
          const i = players.findIndex((x) => x.pid === p.pid);
          return i === -1
            ? players.concat([p])
            : players.map((x, idx) => (idx === i ? { ...x, ...p } : x));
        };
        const playersRemove = (players, pid) =>
          players.filter((p) => p.pid !== pid);

        // ---------------------------
        // State + reducer-ish updates
        // ---------------------------
        let state = Object.freeze({
          players: [], // [{pid, name, ready}]
          phase: "", // string
          ready: false, // our local toggle target
          socket: null, // WebSocket
          es: null, // EventSource
        });

        const setState = (patch) => {
          state = {
            ...state,
            ...(typeof patch === "function" ? patch(state) : patch),
          };
          render();
          return state;
        };

        const render = () => {
          // phase
          phaseEl.textContent = `Phase: ${state.phase || ""}`;
          // players
          playersUl.innerHTML = "";
          playersUl.appendChild(viewPlayers(state.players));
          // ready button label (reflect local intent)
          readyBtn.textContent = state.ready ? "Unready" : "Ready";
        };

        // ---------------------------
        // Effects (I/O)
        // ---------------------------
        const postJSON = async (url, body) => {
          try {
            const res = await fetch(url, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body),
            });
            return {
              ok: res.ok,
              data: res.ok ? await res.json().catch(() => null) : null,
            };
          } catch (e) {
            console.error("POST failed", url, e);
            return { ok: false, data: null };
          }
        };

        const navigateToGame = () => {
          const p = new URLSearchParams({ roomId, token });
          location.href = "room_game.html?" + p.toString();
        };

        // WebSocket (presence/keepalive/reconnect)
        const connectWS = () => {
          if (state.socket) {
            try {
              state.socket.close();
            } catch {}
          }
          const ws = new WebSocket(WS_URL);
          ws.onclose = () => setTimeout(connectWS, 1000);
          setState({ socket: ws });
        };

        // Server-Sent Events wiring
        const connectSSE = () => {
          if (state.es) {
            try {
              state.es.close();
            } catch {}
          }
          const es = new EventSource(`/rooms/${roomId}/sse`);

          es.addEventListener("snapshot", (e) => {
            try {
              const data = JSON.parse(e.data);
              const players = Array.isArray(data.clients)
                ? data.clients.map((c) => ({
                    pid: c.pid,
                    name: c.name,
                    ready: !!c.ready,
                  }))
                : [];
              setState({
                phase: data.phase || "",
                players,
              });
              if (data.phase === "Playing") navigateToGame();
            } catch {}
          });

          es.addEventListener("room", (e) => {
            let ev;
            try {
              ev = JSON.parse(e.data);
            } catch {
              return;
            }
            switch (ev.type) {
              case "player_joined": {
                setState((s) => ({
                  players: playersUpsert(s.players, {
                    pid: ev.pid,
                    name: ev.name,
                    ready: false,
                  }),
                }));
                break;
              }
              case "player_left": {
                setState((s) => ({
                  players: playersRemove(s.players, ev.pid),
                }));
                break;
              }
              case "phase_changed": {
                setState({ phase: ev.phase || "" });
                if (ev.phase === "Playing") navigateToGame();
                break;
              }
              case "ready_changed": {
                setState((s) => ({
                  players: playersUpsert(s.players, {
                    pid: ev.pid,
                    ready: !!ev.ready,
                  }),
                }));
                // Optional: if this was *you*, reflect on the button by mirroring server truth.
                // We don't have a reliable self pid here; keeping local `state.ready` as the toggle hint is fine.
                break;
              }
              case "score_update":
              case "round_start":
              case "round_over":
              default:
                break;
            }
          });

          setState({ es });
        };

        // ---------------------------
        // UI events (compose effects)
        // ---------------------------
        readyBtn.addEventListener("click", async () => {
          const desired = !state.ready;
          // optimistic local toggle (button label); server will broadcast actual readiness via SSE
          setState({ ready: desired });
          await postJSON(`/rooms/${roomId}/ready`, { token, ready: desired });
        });

        // ---------------------------
        // Boot
        // ---------------------------
        connectWS();
        connectSSE();
        render();
      })();
    </script>
  </body>
</html>
