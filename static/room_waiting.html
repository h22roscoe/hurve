<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>Hurve Room â€“ Waiting</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style>
      :root {
        --bg: #0b0d12;
        --fg: #e8eef8;
        --muted: #94a3b8;
        --accent: #22d3ee;
      }

      html,
      body {
        height: 100%;
        margin: 0;
        background: var(--bg);
        color: var(--fg);
        font: 14px/1.4 system-ui, -apple-system, "Segoe UI", Roboto, Ubuntu,
          Cantarell, Arial, sans-serif;
      }

      .wrap {
        display: flex;
        flex-direction: column;
        height: 100%;
      }

      header,
      footer {
        padding: 10px 12px;
        border-bottom: 1px solid #1f2937;
      }

      footer {
        border-bottom: none;
        border-top: 1px solid #1f2937;
        color: var(--muted);
      }

      main {
        flex: 1;
        padding: 12px;
      }

      ul {
        list-style: none;
        padding: 0;
        margin: 0;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      li {
        background: #0f172a;
        padding: 8px 10px;
        border-radius: 6px;
      }

      button {
        padding: 6px 12px;
        border: none;
        border-radius: 6px;
        background: var(--accent);
        color: #000;
        cursor: pointer;
      }

      .row {
        display: flex;
        align-items: center;
        gap: 12px;
      }

      .grow {
        flex: 1;
      }
    </style>
  </head>

  <body>
    <div class="wrap">
      <header class="row">
        <strong>Room â€“ Waiting</strong>
        <span id="phase" class="grow">Phase: Waiting</span>
        <button id="readyBtn" title="Ready">Ready</button>
      </header>
      <main>
        <h3>Players</h3>
        <ul id="players"></ul>
      </main>
      <footer>
        This view will automatically switch to the game when the round starts.
      </footer>
    </div>
    <script>
(() => {
  // ---------------------------
  // Params & derived WS URL
  // ---------------------------
  const q = new URLSearchParams(location.search);
  const roomId = q.get("roomId");
  const token  = q.get("token");
  if (!roomId || !token) {
    alert("Missing roomId/token");
    return;
  }
  const WS_URL = (location.protocol === "https:" ? "wss://" : "ws://")
               + location.host
               + "/ws/" + roomId + "/" + token;

  // ---------------------------
  // DOM elements
  // ---------------------------
  const playersUl = document.getElementById("players");
  const phaseEl   = document.getElementById("phase");
  const readyBtn  = document.getElementById("readyBtn");

  // ---------------------------
  // Tiny helpers (pure)
  // ---------------------------
  const h = (tag, props = {}, children = []) => {
    const el = document.createElement(tag);
    for (const [k, v] of Object.entries(props)) {
      if (k === "class") el.className = v;
      else if (k === "dataset") Object.assign(el.dataset, v);
      else if (k === "style" && typeof v === "object") Object.assign(el.style, v);
      else el.setAttribute(k, v);
    }
    for (const c of [].concat(children)) {
      el.appendChild(typeof c === "string" ? document.createTextNode(c) : c);
    }
    return el;
  };
  const t = s => document.createTextNode(s);

  const viewPlayer = ({ pid, name, ready }) =>
    h("li", {}, [
      h("span", { id: `player-${pid}` }, [name]),
      h("span", { class: "readiness", style: { marginLeft: "0.5rem" } }, [ready ? "ðŸš€" : "â³"])
    ]);

  const viewPlayers = (players) => {
    const frag = document.createDocumentFragment();
    for (const p of players) frag.appendChild(viewPlayer(p));
    return frag;
  };

  // pure transforms for SSE events
  const playersUpsert = (players, p) => {
    const i = players.findIndex(x => x.pid === p.pid);
    return i === -1
      ? players.concat([p])
      : players.map((x, idx) => idx === i ? { ...x, ...p } : x);
  };
  const playersRemove = (players, pid) =>
    players.filter(p => p.pid !== pid);

  // ---------------------------
  // State + reducer-ish updates
  // ---------------------------
  let state = Object.freeze({
    players: [],     // [{pid, name, ready}]
    phase: "",       // string
    ready: false,    // our local toggle target
    socket: null,    // WebSocket
    es: null         // EventSource
  });

  const setState = (patch) => {
    state = { ...state, ...(typeof patch === "function" ? patch(state) : patch) };
    render();
    return state;
  };

  const render = () => {
    // phase
    phaseEl.textContent = `Phase: ${state.phase || ""}`;
    // players
    playersUl.innerHTML = "";
    playersUl.appendChild(viewPlayers(state.players));
    // ready button label (reflect local intent)
    readyBtn.textContent = state.ready ? "Unready" : "Ready";
  };

  // ---------------------------
  // Effects (I/O)
  // ---------------------------
  const postJSON = async (url, body) => {
    try {
      const res = await fetch(url, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      return { ok: res.ok, data: res.ok ? await res.json().catch(() => null) : null };
    } catch (e) {
      console.error("POST failed", url, e);
      return { ok: false, data: null };
    }
  };

  const navigateToGame = () => {
    const p = new URLSearchParams({ roomId, token });
    location.href = "room_game.html?" + p.toString();
  };

  // WebSocket (presence/keepalive/reconnect)
  const connectWS = () => {
    if (state.socket) { try { state.socket.close(); } catch {} }
    const ws = new WebSocket(WS_URL);
    ws.onclose = () => setTimeout(connectWS, 1000);
    setState({ socket: ws });
  };

  // Server-Sent Events wiring
  const connectSSE = () => {
    if (state.es) { try { state.es.close(); } catch {} }
    const es = new EventSource(`/rooms/${roomId}/sse`);

    es.addEventListener("snapshot", (e) => {
      try {
        const data = JSON.parse(e.data);
        const players = Array.isArray(data.clients)
          ? data.clients.map(c => ({ pid: c.pid, name: c.name, ready: !!c.ready }))
          : [];
        setState({
          phase: data.phase || "",
          players
        });
        if (data.phase === "Playing") navigateToGame();
      } catch {}
    });

    es.addEventListener("room", (e) => {
      let ev; try { ev = JSON.parse(e.data); } catch { return; }
      switch (ev.type) {
        case "player_joined": {
          setState(s => ({ players: playersUpsert(s.players, { pid: ev.pid, name: ev.name, ready: false }) }));
          break;
        }
        case "player_left": {
          setState(s => ({ players: playersRemove(s.players, ev.pid) }));
          break;
        }
        case "phase_changed": {
          setState({ phase: ev.phase || "" });
          if (ev.phase === "Playing") navigateToGame();
          break;
        }
        case "ready_changed": {
          setState(s => ({ players: playersUpsert(s.players, { pid: ev.pid, ready: !!ev.ready }) }));
          // Optional: if this was *you*, reflect on the button by mirroring server truth.
          // We don't have a reliable self pid here; keeping local `state.ready` as the toggle hint is fine.
          break;
        }
        case "score_update":
        case "round_start":
        case "round_over":
        default:
          break;
      }
    });

    setState({ es });
  };

  // ---------------------------
  // UI events (compose effects)
  // ---------------------------
  readyBtn.addEventListener("click", async () => {
    const desired = !state.ready;
    // optimistic local toggle (button label); server will broadcast actual readiness via SSE
    setState({ ready: desired });
    await postJSON(`/rooms/${roomId}/ready`, { token, ready: desired });
  });

  // ---------------------------
  // Boot
  // ---------------------------
  connectWS();
  connectSSE();
  render();
})();
</script>

  </body>
</html>
